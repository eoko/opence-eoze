<?php
/**
 * @package PS-ORM-1
 * @author Éric Ortéga <eric@mail.com>
 * @copyright Copyright (c) 2010, Éric Ortéga
 * @license http://www.planysphere.fr/licenses/psopence.txt
 */

/**
 * Base class of Model classes
 *
 * This class provides the common functionnalities of all models. It is used as
 * the parent class for all xxxModel classes.
 *
 * For each data model of the application (actually each table), an xxxModel
 * and an xxxModelBase classes will be generated, where xxx stands for the
 * model name. The xxxModel class is almost empty when it is created, and is
 * meant to support configuration and customization of the model by the user;
 * this class file will be generated only if it does not already exist.
 * On the contrary, the xxxModelBase will be overwritten each time the models
 * are updated. This class is not intended to be modified by the user. It
 * provides all functionnality which are specific to a given model, yet are
 * deciphered by the generation algorithm.
 *
 * Similarly, two xxxModelTable and xxxModelTableBase will be generated to
 * provide functionnalities of the model's generic properties (as opposed to
 * the model's reccords properties). See {@link ModelTable} for details.
 *
 * @method ModelTable getTable() Get the ModelTable corresponding to this Model.
 * This function can be statically called from concrete implementations of Model
 * (but not in, or from, the Model class itself, where it is not defined).
 *
 * @internal The methods of the Model class which are protected, and
 * prefixed with a single underscore (eg _load) will have a static alias created
 * in the generated ModelBase classes. These alias method will consist of a
 * static public method, named after the name of the parent method without the
 * underscore prefix; their execution consists in calling the corresponding
 * parent method with the model's {@link ModelTable} as its first parameter.
 *
 * @internal the Model class is not allowed to have any method which name begins
 * with get or set, to avoid conflict with the getter and setter methods
 * autogenerated for the model field.
 */
abstract class Model {

	private static $enumLabels;

	/** @var ModelInternal */
	private $internal;
	/** @var myModelTable */
	protected $table;

	/**
	 * True if all fields have been set (from the database, usually), else false.
	 * @var bool
	 */
	private $dbImage = false;

	protected $initiated = false;

	/**
	 * @var boolean If set to TRUE, the model will be considered new even if the
	 * primary key is set. This is needed for model that have a primary key that
	 * is also used as data, since the primary key field can be set by the user.
	 * The value of $forceNew is cleared each time the model is saved.
	 */
	private $forceNew = null;

	private $forcedAllFieldsUpdate = false;

	protected $determinationMultifieldListeners = null;
	protected $determinationListeners = null;
	protected $undeterminedFields = array();

	protected $deleted = false;

	const EVT_BEFORE_SAVE_BASE = 'beforeSave';
	const EVT_AFTER_SAVE_BASE = 'afterSave';
	const EVT_BEFORE_SAVE_RELATION = 'beforeSaveRelation';
	const EVT_AFTER_SAVE_RELATION = 'afterSaveRelation';

	const EVT_AFTER_INIT = 'afterInit';

	protected $listeners = array(
		self::EVT_BEFORE_SAVE_BASE => array()
		,self::EVT_AFTER_SAVE_BASE => array()
		,self::EVT_BEFORE_SAVE_RELATION => array()
		,self::EVT_AFTER_SAVE_RELATION => array()
	);

	/** @var EventManager */
	public $events;

	public $context;

	protected function __construct(&$fields, array $initValues = null, 
			$strict = false, array $context = null) {

		$this->events = new EventManager();

		$this->table = $this->getTable();

		$this->internal = new ModelInternal($this);

		$this->internal->fields = $fields;

		$this->context = $context;
//		foreach ($this->internal->fields as $k => $v) {
//			$this->internal->colUpdated[$k] = false;
//		}

//		$this->internal->relations = $relations;

		$this->initializeBase();
		$this->initialize();

		if ($initValues !== null) {
			if ($strict) {
				$this->setAllFieldsFromDatabase($initValues);
			} else {
//				$this->setFields($initValues, false);
				$this->setFields($initValues, true);
			}
		}

		$this->onModelCreate();

		$this->initiated = true;
		$this->events->fire(self::EVT_AFTER_INIT);
	}

	public function setContextIf($context) {
		if ($context !== null && count($context) !== 0 
			&& ($this->context === null || count($this->context) == 0)) {

			$this->context = $context;
		}
	}

	protected function onModelCreate() {
		// overriden
	}

	/**
	 * Initialize the Model reccord
	 * 
	 * This method is intended to be used instead of the constructor, to do
	 * configuration and initialization tasks.It is indeed not safe for Model
	 * concrete implementations to override their parent's constructor.
	 * 
	 * This method is called each time a new reccord Object is created.
	 *
	 * @internal This empty implementation is kept in the base class, in case the
	 * childs ones got deleted...
	 */
	protected function initialize() {
		// initialization ...
	}

	protected function initializeBase() {
		// initialization ...
	}

	/**
	 * @return ModelTable
	 */
	abstract public static function getTable();

	public function __isset($name) {
		return array_key_exists($name, $this->internal->fields);
	}

	public function __unset($name) {
		throw new UnsupportedOperationException('Cannot remove fields from models');
	}

	public function __get($fieldName) {
		return $this->getFieldValue($fieldName);
	}

	/**
	 * Resolves the $field name (-> format) and returns its value. If a variable
	 * is passed in the $model param, it will be set to reference the actual
	 * model that own the field.
	 * @param string $field
	 * @param Model $model
	 * @param ModelField $modelField
	 * @return mixed
	 */
	private function getFieldValue($field, &$model = null, &$modelField = null) {

		if (array_key_exists($field, $this->internal->fields)) {
			$model = $this;
			$modelField = $field;
			return $this->getField($field);
		} 

		else if ($this->table->hasVirtual($field)
				|| $this->table->hasVirtual($field = lcfirst($field))) {

			$model = $this;
			$modelField = $field;

			if (array_key_exists($field, $this->virtualFieldsCache)) {
				return $this->virtualFieldsCache[$field];
			}

			$r = $this->table
					->createQuery($this->context)
					->select($field)
					->where("`{$this->getPrimaryKeyName()}`=?", 
							$this->getPrimaryKeyValue())
					->executeSelectValue();

			$r = $this->table->getVirtual($field)->castValue($r);

			if ($this->table->isVirtualCachable($field)) {
				$this->virtualFieldsCache[$field] = $r;
			}

			return $r;
		}

		else {
			$relName = ucfirst($field);

			if (count($parts = explode('->', $relName)) > 1) {
				$last = array_pop($parts);
				$relModel = $this;
				foreach ($parts as $rel) {
					if (null === $relModel = $relModel->getForeignModel($rel)) {
						return null;
					}
				}
				$model = $relModel;
				$modelField = $last;

//				return $relModel->__get($last);
				return $relModel->getFieldValue($last);
			} else {
				if ($this->getTable()->hasRelation($relName)) {
					return $model = $this->getForeignModel($relName);
				}
			}
		}
		throw new IllegalArgumentException(get_class($this) . " has no field '$field'");
	}

	public function __set($fieldName, $value) {
		Logger::dbg('Setting {} => {}', $fieldName, $value);
		if ($this->getTable()->getColumn($fieldName)->isPrimary()) {
			$this->setPrimaryKeyValueImpl($fieldName, $value);
		} else {
			$this->setField($fieldName, $value, false);
		}
	}

	public function echoIf($field, $defaultValue = '-', $exludeEmptyString = true, $render = true) {
		if (
			(null === $v = $this->__get($field))
			|| ($exludeEmptyString && $v === '')
		) {
			echo $defaultValue;
		}
		else {
			if ($render) {
				echo $this->doRenderField($field, $v);
			} else {
				echo $v;
			}
		}
	}

	private function formatForRender($field, $value) {
		if ($this->table->renderers && isset($this->table->renderers[$field])) {
			return ModelFieldRenderer::apply(
				$this->table->renderers[$field],
				$value !== null ? $value : $this->__get($field),
				$this
			);
		} else if (isset(self::$enumLabels[$field])) {
			if (isset(self::$enumLabels[$field][$value])) {
				return self::$enumLabels[$field][$value];
			} else {
				throw new IllegalStateException('Illegal value for enum: ' . $value);
			}
		} else if ($value !== null) {
			$mf = $this->table->getField($field);
			switch ($mf->getType()) {
				case ModelField::T_DATE:
					return date('d/m/Y', strToTime($value));
				case ModelField::T_BOOLEAN:
					return $value ? 'Oui' : 'Non';
				case ModelField::T_ENUM:
					return $mf->getEnumLabelForValue($value);
				default:
					return $value;
			}
		} else {
			return $value;
		}
	}

	private function doRenderField($field, $value = null) {
		$v = $this->getFieldValue($field, $model, $field);
		if ($value === null) $value = $v;
		return $model->formatForRender($field, $value);
//		if ($this->table->renderers !== null
//				&& isset($this->table->renderers[$field])) {
//			return ModelFieldRenderer::apply(
//				$this->table->renderers[$field],
//				$value !== null ? $value : $this->__get($field),
//				$this
//			);
//		} else {
//			return $value !== null ? $value : $this->__get($field);
//		}
	}

	public function renderField($field) {
		return $this->doRenderField($field);
	}

	/**
	 * Proxy method for Logger::GetLogger('ModelName')
	 * @return Logger
	 */
	private function getLogger() {
		return Logger::getLogger($this->getModelName());
	}

	/**
	 * Get this Model's class name as a string
	 * @return String
	 */
	abstract protected function getModelName();

	/**
	 * Get the value of this Reccord's primary key.
	 * @return <mixed>
	 */
	abstract function getPrimaryKeyValue();

	public function getPrimaryKeyName() {
		return $this->getTable()->getPrimaryKeyName();
	}

	const F_COLUMN = 1;
//	const F_FOREIGN_FIELD = 2;
//	const F_FOREIGN_NAME = 4;
//	const F_FOREIGN_ID = 8;
//	const F_FOREIGN_ALL = 14;
	const F_VIRTUALS = 16;
	const F_ALL = 31;

	/**
	 * @return Array	$fieldName => $value
	 */
	public function getFields($fields = null) {
		if ($fields === null) {
			$fields = array_keys($this->internal->fields);
		}
		if (is_array($fields)) {
			$r = array();
			foreach ($fields as $field) {
				$r[$field] = $this->getField($field);
			}
			return $r;
		} else if (is_int($fields)) {
			$r = array();
			foreach ($this->internal->fields as $name => $val) {
				if ($this->table->hasColumn($name)) {
					if ($fields & self::F_COLUMN) $r[$name] = $val;
				} else if ($this->table->hasVirtual($name)) {
					if ($fields & self::F_VIRTUALS) $r[$name] = $val;
				} else {
					throw new IllegalStateException("What is this field: $name");
				}
			}
			return $r;
		} else {
			throw new IllegalArgumentException();
		}
	}

	/**
	 * @param String $aliasPrefix	optionnal alias prefix to be prepended to
	 * all fields' name
	 * @return Array	[$aliasPrefix]$colName => $value
	 */
	public function getData($aliasPrefix = null) {
		if ($aliasPrefix === null) {
			return $this->getFields();
		} else {
			$r = array();
			foreach ($this->getFields() as $col => $val) {
				$r[$aliasPrefix . $col] = $val;
			}
			return $r;
		}
	}

	/**
	 * Get the value of each field in the given array.
	 * 
	 * The names of the field in the returned array can be aliased by
	 * specifying this alias as the key of the field in the passed
	 * $fields array.
	 * 
	 * Example:
	 * <code>
	 *     $alias => $field
	 * </code>
	 * 
	 * If no alias is specified, the name of the field will be used.
	 * 
	 * Special value '*' is allowed to add all base fields of the Model
	 * to the returned array.
	 * 
	 * This method will extend the passed fields to the model's virtual 
	 * fields, relations, and fields of its relations.
	 * 
	 * The following field specification are all legal:
	 * 
	 * <code>
	 *     '*', // alias for all the model's base fields
	 *     'my_simple_field',
	 *     'myVirtualField',
	 *     'MyRelation',
	 *     'MyRelation->id',
	 * </code>
	 * 
	 * @param array $fields
	 * @return array
	 */
	public function getDataAs($fields) {
		$return = array();
		foreach ($fields as $alias => $field) {
			if ($field === '*') {
				$prefix = is_string($alias) ? $alias : null;
				foreach ($this->getFields() as $name => $value) {
					$alias = $prefix . $name;
					if (!array_key_exists($alias, $return)) {
						$return[$alias] = $value;
					}
				}
			} else {
				// get data
				$data = $this->getFieldValue($field);
				// convert Model & ModelSet
				if ($data instanceof ModelSet) {
					$setData = array();
					foreach ($data as $model) {
						$setData[] = $model->getData();
					}
					$data = $setData;
				} else if ($data instanceof Model) {
					$data = $data->getData();
				}
				// save
				if (!is_string($alias)) {
					$alias = $field;
				}
				$return[$alias] = $data;
			}
		}
		return $return;
	}

	// TODO this should be documented & have unit tests
	// it is known to be used twice in opence, and in:
	// OpenCE:
	// - SmInstance.grid.class.php
	public function getDataEx($relationNames, $aliasPrefix = null, $includeBaseData = true) {
		$data = $includeBaseData ? $this->getData($aliasPrefix) : array();

		if ($relationNames === '*') {
			$relationNames = $this->table->getRelationNames();
		} else if (!is_array($relationNames)) {
			$r = $this->getDataEx(array($relationNames), null, false);
			return $r[$relationNames];
		}

		foreach ($relationNames as $k => $rName) {

			if (is_string($k)) {
				$params = $rName;
				$rName = $k; // relation name
			} else {
				$params = null;
			}

			if (null !== $foreignModel = $this->getForeignModel($rName)) {
				if ($foreignModel instanceof Model) {
					if (!$params) {
						$data = array_merge($data, $foreignModel->getData("$aliasPrefix{$rName}->"));
					} else {
						$data = array_merge($data, $foreignModel->getDataEx($params, "$aliasPrefix{$rName}->"));
					}
				} else if ($foreignModel instanceof ModelSet) {
					// we have a HasMany relation here...
					$hasManyData = array();
					foreach ($foreignModel as $model) {
						if ($params) {
							$hasManyData[] = $model->getDataEx($params);
						} else {
							$hasManyData[] = $model->getData();
						}
					}
					$data["$aliasPrefix$rName"] = $hasManyData;
				} else {
					throw new IllegalStateException();
				}
			} else {
				$data["$aliasPrefix$rName"] = null;
			}
		}
		return $data;
	}

	public function testIntegrity($operation, $return = false) {
		// TODO testIntegrity could be used to ensure that fields' value do
		// respects the BL constraints.

		// Fields should not be tested against NULL if the Model isn't new. NULL
		// means that the field has not been modified, but it is expected to be
		// valid in the datastore, since it must have passed an integrity test
		// before being created.
		// Since no other test are performed for now, we might as well return now...
		if (!$this->isNew()) return true;

		foreach ($this->table->getColumns() as $col) {
			$value = $this->getField($col->name);
			if ($value === null) {
				if (!$col->isNullable()) {
					if (!($col->isPrimary() && $this->isNew()) && !$col->hasDefault() && !$col->isAuto($operation)) {
						if ($return) {
							return false;
						} else {
							throw new SystemException("{$this->getModelName()}.$col->name must be set in $this");
						}
					}
				}
			} else {
				if ($col instanceof ModelColumn) {
					if (!$col->validateLength($value, $len, $maxLength)) {

						$label = $col->getMeta()->get('label', $col->getName());
						$label = lcfirst($label);

						if (strstr($maxLength, ',')) {
							list($maxInt, $maxDec) = explode(',', $maxLength);
							$maxInt = max(0, $maxInt - $maxDec);
							$humanMaxLength = "$maxInt chiffre" . ($maxInt > 1 ? 's' : '')
									. " et $maxDec chiffre" . ($maxDec > 1 ? 's' : '')
									. " après la virgule";
						} else {
							$humanMaxLength = "$maxLength chiffre" . ($maxLength > 1 ? 's' : '');
						}

						throw new UserException(
							"La valeur du champ <em>$label</em> dépasse la longueur maximale "
							. "autorisée de $humanMaxLength."
						);
					}
				}
			}
		}
		return true;
	}

	/**
	 * Marks all fields as modified. This will has effect until after the 
	 * next successful saving operation.
	 */
	public function touchAllFields() {
		$this->forcedAllFieldsUpdate = true;
	}

	/**
	 * Returns an array containing all the reccord's fields that have changed,
	 * and thus need to be modified in the database. The array's key are the
	 * field's name in the database, and the value are the value (in a
	 * form compatible with the SQL).
	 * <p>This method can only be called when <b>actually</b> intending to
	 * commit the changes, since it will check for some integrety (final fields),
	 * and throw exceptions in case of problem.
	 * <p>If some automatic set operations are associated with this Model's
	 * ModelColumns, then they will be set by this method, but only if the
	 * matching field's value have not already been (ie. auto values do not
	 * have priority over non-auto changes).
	 * @return Array $colName => $value
	 */
	private function buildUpdatedFields($operation) {

		$r = array();

		// This means that no column value has been set
		if ($this->internal->colUpdated === null) {
			return $r;
		}

		foreach ($this->getFields(self::F_COLUMN) as $k => $v) {
//			if (($this->internal->fields[$k] !== null && $this->internal->colUpdated[$k])) {
			if ($this->forcedAllFieldsUpdate
					|| isset($this->internal->colUpdated[$k]) && $this->internal->colUpdated[$k]) {
				$r[$k] = $v;
			} else {
				// Cache fields's col
				if (!$this->table->hasVirtual($k)) {
					$col = $this->table->getColumn($k);
				}

				// If the reccord is new and the field final, and it has not
				// been explicitely set, we *must* find an auto or default value
				if ($this->isNew() && $col->isFinal()) {
					if ($col->isAuto($operation)) {
						$r[$k] = $col->getAutoValue($operation);
					} else if (!$col->hasDefault()) {
						throw new IllegalStateException(
							'Final col not set: ' . get_class($this) . "->$col->name"
						);
					}

				// ... else, process auto value (eg. update date)
				} else if ($col->isAuto($operation)) {
					$r[$k] = $col->getAutoValue($operation);
				}
			}
		}
		return $r;
	}

	/**
	 * Whether this Model represent a new record (that is, one that doesn't have
	 * a matching representation in the database). A newly instanciated Model is
	 * considered new, until one of the following happens:
	 *
	 * <ul>
	 * <li>some model's data is loaded from the database,
	 * <li>the model is successfuly persisted (saved) in the database,
	 * <li>or the model's primary key is set to a non-NULL value
	 * </ul>
	 *
	 * In the two first cases, the reccord is garanteed to have a matching
	 * representation in the database (unless some external operation have
	 * removed it), while in the third case, that will be known only when the
	 * reccord will be saved.
	 *
	 * This property has an effect on the operation conducted by the save()
	 * method of the model (new reccords will be created, will non-new reccords
	 * will be updated).
	 *
	 * @return boolean
	 */
	public function isNew() {
		//return $this->getPrimaryKeyValue() !== null;
		return $this->forceNew === true ||
			$this->internal->fields[$this->getPrimaryKeyName()] === null;
	}

	/**
	 * Forces the model to be considered new. That may be needed when the
	 * model's primary key also represent some actual data, since the primary
	 * key field value may be set by the user, thus tricking the automatic
	 * algorithm evaluating if the model is new into thinking that it isn't.
	 *
	 * The forced new state will be cleared each time the model is successfuly
	 * saved in the datastore (database).
	 *
	 * @return Model $this
	 */
	public function forceNew() {
		$this->forceNew = true;
		return $this;
	}

	/**
	 * @return bool `true` if the model has been deleted, or will be deleted on next
	 * call to the {@link Model::save() save()} method.
	 */
	public function wasDeleted() {
		return $this->deleted;
	}

	/**
	 * Returns true if the specified field or fields have been modified.
	 *
	 * If the method is called with no arguments, it will return true if *any* field
	 * has been modified.
	 *
	 * @param null|string|string[] $fieldName
	 * @param ...
	 * @return bool
	 */
	public function isModified($fieldName = null) {
		// Multiple arguments
		if (func_num_args() > 1) {
			$fieldName = func_get_args();
		}
		// Multiple fields
		if (is_array($fieldName)) {
			foreach ($fieldName as $field) {
				if ($this->isModified($field)) {
					return true;
				}
			}
			return false;
		}
		// Single field
		if ($fieldName === null) {
			return $this->internal->modified;
		} else {
			return isset($this->internal->colUpdated[$fieldName])
				&& $this->internal->colUpdated[$fieldName];
		}
	}

	private $virtualFieldsCache = array();

	public function __call($name, $args) {
		if (substr($name, 0, 3) === 'get') {
			$k = substr($name, 3);
			if ($this->table->hasVirtual($k)
					|| $this->table->hasVirtual($k = lcfirst($k))) {

				if (array_key_exists($k, $this->virtualFieldsCache)) {
					return $this->virtualFieldsCache[$k];
				}

				if ($this->isNew()) {
					throw new UnsupportedOperationException("$name must be implemented for new models.");
				}

				$table = $this->getTable();

				$r = $table
						->createQuery($this->context)
						->select($k)
						->where("`{$this->getPrimaryKeyName()}` = ?", $this->getPrimaryKeyValue())
						->executeSelectValue();

				if ($table->isVirtualCachable($k)) {
					$this->virtualFieldsCache[$k] = $r;
				}

				return $r;
			}

			// 06/12/11 22:46
			// Get from relation
			$relationName = ucfirst($k);
			if (null !== $f = $this->table->hasRelation($relationName)) {
				$relation = $this->getForeignModel($relationName);
				return $relation;
			}
		}
		throw new Exception("Undefined method: $name()");
	}

	public function getInitialValue($fieldName) {
		if ($this->internal->dbValues === null) {
			if ($this->isNew()) {
				return null;
			} else {
				$this->internal->dbValues = $this->table->loadModel(
					$this->getPrimaryKeyValue()
				)->internal->dbValues;
				return $this->getInitialValue($fieldName);
			}
		} else {
			return $this->internal->dbValues[$fieldName];
		}
	}

	/**
	 * Save the model, or throw an exception in case of failure.
	 * @throws ModelSaveException if the model saving operation fails.
	 */
	public function saveManaged($new = null, $exMsg = null) {
		try{
			$this->save($new);
		} catch (Exception $ex) {
			throw new ModelSaveException($exMsg, null, $ex);
		}
	}

	protected function beforeSave($new) {}
	protected function afterSave($new) {}

	protected function beforeSaveRelation(ModelRelation $relation, $newRecord) {
		if (method_exists($this, $m = "beforeSaveRelation_$relation->name")) {
			$this->$m($relation, $newRecord);
		}
	}
	protected function afterSaveRelation(ModelRelation $relation) {
	}
	protected function afterSaveRelations($wasNew) {
	}

	/**
	 * Event method called unconditionnaly before any save operation, that is
	 * even if the Model's data won't be persisted to the datastore (which
	 * occurs only if the Model is new or modified). See {@link Model::beforeSave} 
	 * and {@link Model::afterSave} for conditionnal events.
	 * @param boolean $new 
	 */
	protected function onPrepareForSave(&$new, $deleted) {}

	/**
	 * This flag is set to `true` when the record is being saved, else it is set
	 * to `false`.
	 * @var boolean
	 */
	private $saving = false;

	/**
	 * This flag is set to `true` if the {@link save()} method is called when
	 * the record is {@link isSaving() being saved} then, when the record has
	 * been saved (including its relation), a save operation is triggered
	 * again and this flag is turned to `false` again.
	 * @var boolean
	 */
	private $saveAgain = false;

	/**
	 * Persists the reccord in the database. If the primary key of the reccord
	 * has been set, this will result in an <b>update</b> operation; while if
	 * it has been left blank, a new reccord will be created.
	 * @return Bool TRUE if succeeds, FALSE if fails.
	 */
	public function save($new = null) {

		if ($this->saving) {
			$this->saveAgain = true;
		}

		$new = $new === true || $this->isNew();

		// Relation to which the parent model holds a reference field must be
		// saved before it, to that primary keys of new referenced model can
		// be known at the time of saving the parent.
		// The reverse should not be a problem, as long as the parent model is
		// not new, or the referenced model doesn't hold a reference back to
		// its parent. Else, we are stuck.
//		$success = true;
//		foreach ($this->internal->relations as $relation) {
//			if ($relation instanceof ModelRelationHasReference) {
//				if (!$this->saveRelation($relation, $new)) $success = false;
//			}
//		}

		$this->onPrepareForSave($new, $this->deleted);

		$success = true;

		if ($this->deleted) {
			if (!$new) {
				$this->doDelete(true);
			}
		} else {

			$this->saving = true;

			if ($new) {

				// Operation is CREATE
				$this->events->fire(self::EVT_BEFORE_SAVE_BASE, $this);
				$this->beforeSave(true);

				// test integrity *after* listeners have had the opportunity
				// to preprocess the model in the beforeSave event
				$this->testIntegrity(ModelColumn::OP_CREATE);

				$id = $this->getTable()->createQuery($this->context)
						->insert()
						->set($this->buildUpdatedFields(ModelColumn::OP_CREATE))
						->executeInsert();

				// TODO: check the return of PDO lastInsertId when for tables with no id or primary key
				if ($id === null) {
					throw new ModelSaveException('Cannot get last id of created model');
				}
				if ($this->hasPrimaryKey()) {
					$this->setPrimaryKeyValue($id);
				}

				$this->afterCommitChanges();

				// afterSave event (must be fired here, see bellow)
				$this->events->fire(self::EVT_AFTER_SAVE_BASE, $this);
				$this->afterSave(true);
			} else if ($this->isModified()) {
				// Operation is UPDATE
				$this->events->fire(self::EVT_BEFORE_SAVE_BASE, $this);
				$this->beforeSave(false);

				// test integrity *after* listeners have had the opportunity
				// to preprocess the model in the beforeSave event
				$this->testIntegrity(ModelColumn::OP_UPDATE);

				if ($this->commitChanges()) {

					// TODO: implement the modification success check
					// if ($affectedRows != 1) return false;

					// afterSave event (must be fired here, see bellow)
					$this->events->fire(self::EVT_AFTER_SAVE_BASE, $this);
					$this->afterSave(false);
				}
			}

			// Propagate the save operation to all instanciated relations. The
			// said relations may already have saved themselves on the afterSave
			// event, but a call to save() is required to have no effect on unmodified
			// items... So, trying to keep track of modified vs unmodified relations
			// in the Model would only produce useless overhead.
			foreach ($this->internal->relations as $relation) {
				if (!$this->saveRelation($relation, $new)) {
					throw new ModelSaveException('Failed saving relation: ' . $relation);
				}
			}

			$this->afterSaveRelations($new);
			$this->saving = false;

			if ($this->saveAgain) {
				$this->saveAgain = false;
				$this->save();
			}
		}

		return true;
	}

	/**
	 * Returns `true` if the model is be
	 * @return boolean
	 */
	public function isSaving() {
		return $this->saving;
	}

	/**
	 * Commits the updated fields of the model to the database.
	 * 
	 * @return bool `true` if the model was modified, else `false`. If the model
	 * is not found modified, no database query will be issued.
	 */
	protected function commitChanges() {

		$setters = $this->buildUpdatedFields(ModelColumn::OP_UPDATE);
		unset($setters[$this->getPrimaryKeyName()]);

		// don't try to save if no field has actually been updated
		if ($setters) {
			$affectedRows = $this->getTable()->createQuery($this->context)
					->set($setters)
					->where($this->getPrimaryKeyName() . ' = ?', $this->getPrimaryKeyValue())
					->executeUpdate();

			$this->afterCommitChanges();
			return true;
		} else {
			$this->afterCommitChanges();
			return false;
		}
	}

	private function afterCommitChanges() {

		// Take care, do not fire events or such from here... Look, just above,
		// commitChanges is using this to reset fields, but does not expect
		// more.

		// clear $forceNew state
		$this->forceNew = null;

		// afterSave event
		// The afterSave event must not be fired here, because it must be
		// fired *only* if the model has actually been saved -- ie. if it
		// was new, or if it was modified.

		// Must be done before saving the relations (some of them may try to
		// save their parent model -- eg. ReferencesOne)
		$this->internal->modified = false;

		$this->internal->dbValues = null;

		$this->forcedAllFieldsUpdate = false;
	}

	private function saveRelation(ModelRelation $relation, $parentWasNew) {
		$this->events->fire(self::EVT_BEFORE_SAVE_RELATION, $relation);
		$this->beforeSaveRelation($relation, $parentWasNew);

		if (!$relation->save($parentWasNew)) {
			Logger::get($this)->error(
				"Error saving relation: " . get_class($this) . '.' .
				$relation->getName() . " (" . get_class($relation) . ")"
			);
			return false;
		} else {
			$this->events->fire(self::EVT_AFTER_SAVE_RELATION, $relation);
			$this->afterSaveRelation($relation);
			return true;
		}
	}

	public function on($eventName, $callback, $extraArgs = null) {
		$this->events->on($eventName, $callback, $extraArgs);
	}

	public function onOnce($eventName, $callback, $extraArgs = null) {
		$this->events->onOnce($eventName, $callback, $extraArgs);
	}

	/**
	 * Schedule the Model for deletion, that will be commited on the next call
	 * to the {@link Model::save() save()} method.
	 *
	 * @see Model::delete() to delete the model such that the change is
	 * immediatly commited to the database.
	 * 
	 * @internal CHANGE 16/12/10 23:28 renamed to markDeleted, to fulfill the
	 * no method named get/set in model (to avoid conflict with models business
	 * get/set methods)
	 */
	public function markDeleted() {
		$this->deleted = true;
	}

	/**
	 * Trigger the notification that this model is being deleted. This method
	 * does nothing more; the procedure that called it must handle the actual
	 * modifications in the store itself. This method is intended to allow the
	 * performing of delete events, when the model will be deleted by a source
	 * other than the model self's {@link Model::delete()} or {@link
	 * Model::markDeleted()} methods.
	 *
	 * This method will set the model in a deleted state. If the model is
	 * already in a deleted state, nothing will happen; that is, no event will
	 * be fired.
	 *
	 * Moreover, the deleleted state means that any subsequent call
	 * to the {@link Model::save() save()} method will attempt to actually
	 * delete the model from the datastore. The event will be fired by the
	 * {@link Model::delete() delete()} method, that fires it only if it remove
	 * some actual data from the database. So, whatever the source (the external
	 * one that called this method, or the internal delete() method) that
	 * actually do the job, the cleaning procedure will only be launched once.
	 */
	public function notifyDelete() {
		if (!$this->deleted) {
			$this->beforeDelete(false);
			$this->deleted = true;
			$this->onDeleteInternal();
			$this->onDelete(false);
		}
	}

	/**
	 * Event method called after a model's data has been removed from the
	 * datastore.
	 * @param boolean $isSaving TRUE if the delete operation is taking place in
	 * the save procedure (ie. the Model's {@link Model::save() save()} method),
	 * FALSE if the delete operation has been triggered directly. This 
	 * information can be useful, since if the delete operation occurs in the
	 * process of saving the model (that is, when $isSaving would be TRUE),
	 * that means that the Model's relations will all be saved subsequently to
	 * the deletion of the model.
	 */
	protected function onDelete($isSaving) {}

	/**
	 * Hooking method called when the model is marked for deletion, or when
	 * it is actually in the process of being deleted.
	 * @param boolean $isSaving TRUE if the model is actually being deleted,
	 * FALSE if it is just marked for deletion (actual deletion will then
	 * occur on the next call to the {@link save()} method of this model).
	 */
	protected function beforeDelete($isSaving) {}

	protected function onDeleteInternal() {
		$tableName = $this->table->getTableName();
		foreach ($this->table->getRelationsInfo() as $relInfo) {
			if ($relInfo instanceof ModelRelationInfoIsRefered) {
				$relInfo->notifyDeleteToRefering($this);
//				$this->getRelation($relInfo->name)->notifyDeleteToRefering($this);
			}
		}
	}

	/**
	 * Remove the data that this model represent from the data store. This action
	 * is committed immediately.
	 *
	 * An delete notification, triggering delete postprocessing (including
	 * referring relation cascading) will be trigger <b>only</b> if some data
	 * is actually removed from the database. That means that if the data have
	 * already been removed, the post-processing procedure will not be triggered
	 * again.
	 *
	 * @return bool TRUE if the action has actually affected the database, else
	 * FALSE.
	 * @see Model::markDeleted() to have the model deleted on the next call to the
	 * {@link Model::save() save()} method.
	 */
	public function delete() {
		return $this->doDelete(false);
	}

	/**
	 * Delete this Model by {@link Model::delete() deleting} it from the DB or,
	 * if the Model is new, prevent it from being later persisted in the DB.
	 * 
	 * This method is using the {@link Model::delete() delete()} method
	 * internally, so all related events are fired the same way. Note, however,
	 * than no delete-related events will be fired if there exists no data
	 * from the Model to be actually removed from the database (ie. if the
	 * Model was {@link Model::isNew() new}.
	 * 
	 * @return boolean TRUE if the Model is successfully deleted, or if it was
	 * new; FALSE if the Model's data exists in the DB and cannot be 
	 * successfully removed.
	 * 
	 * @see Model::delete(), Model::markDeleted()
	 */
	public function discard() {
		if (!$this->isNew()) {
			return $this->delete();
		} else {
			// Ensure that the Model cannot be saved
			$this->deleted = true;
			return true;
		}
	}

	// Set to true when the model has been actually removed from the DB.
	// Used to prevent double actual deletion operation, primarily in
	// order to avoid multiple firing of deletion events.
	private $deletedFromDB = false;

	private function doDelete($isSaving) {

		if ($this->isNew()) {
			throw new IllegalStateException('Cannot delete a new model');
		}

		if (!$this->deletedFromDB) {
			$this->beforeDelete($isSaving);

			if ($this->doDeleteQuery()) {

				$this->deletedFromDB = true;
				$this->deleted = true;

				$this->onDeleteInternal();
				$this->onDelete($isSaving);

				return true;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}

	/**
	 * Implements the delete query of the model. When this method is called,
	 * it is guaranteed that the data representing the actual model in the
	 * database do exist.
	 * @return bool `true` on success, `false` on failure.
	 */
	protected function doDeleteQuery() {
		return  1 === $this->getTable()
				->createQuery($this->context)
				->delete()
				->where("`{$this->getPrimaryKeyName()}` = ?", $this->getPrimaryKeyValue())
				->executeDelete();
	}

	protected function applyLoadQueryWherePk(ModelTableQuery $query) {
		$pkName = $this->getPrimaryKeyName();
		$id = $this->internal->fields[$pkName];
		return $query->where(
			$query->getQualifiedName($pkName) . ' = ?', $id
		);
	}

	protected function doLoad() {

		if ($this->isNew()) {
			throw new IllegalStateException(
				'Cannot load a new record that has never been stored in the database.'
			);
		}

		$table = $this->getTable();
		$id = $this->internal->fields[$this->getPrimaryKeyName()];

		// Models should not try to preload relations, that may be catastrophic
		// in the case of a ReferredByMany relation. Eg. A Countries table may
		// be referred by thousands of records that we generally don't want to
		// load with the Country record.
		$query = $table->createLoadQuery(ModelTable::LOAD_NONE, $this->context);

		$result = $this->applyLoadQueryWherePk($query)->executeSelectFirst();

		if ($result == null) {
			return null;
		}

		$this->setAllFieldsFromDatabase($result);

		$this->clearModified();

		return $this;
	}

	/**
	 * @return Model
	 */
	abstract static public function load($id, array $context = array());

	/**
	 * Returns `true` if the given field value has changed, else `false`. If the record
	 * is new, this method will always return `false`.
	 * @param string $field The name of the field to be tested.
	 * @param boolean $strict `true` to use a strict binary comparison, `false` to use
	 * typeless comparison.
	 * @return boolean
	 */
	public function hasChanged($field, $strict = true) {

		if ($this->isNew()) {
			return false;
		}

		$oldValue = $this->doGetStoredCopy(null)->getFieldValue($field);
		$currentValue = $this->getFieldValue($field);

		return $strict
				? $oldValue !== $currentValue
				: $oldValue !=  $currentValue;
	}

	/**
	 * @var Model
	 */
	private $cachedStoredCopy = null;

	/**
	 * @param boolean $loadFromDb
	 * 
	 * -   TRUE to force loading from database;
	 * -   FALSE to never load from database (using cached copy or already loaded
	 *     values instead;
	 * -   NULL to load from database if data have not been loaded already.
	 * 
	 * @return Model
	 */
	protected function doGetStoredCopy($loadFromDb = false) {
		if ($loadFromDb === true) {
			return $this->doDoGetStoredCopy(true);
		} else if (!$this->cachedStoredCopy) {
			$this->cachedStoredCopy = $this->doDoGetStoredCopy($loadFromDb);
		}
		return $this->cachedStoredCopy;
	}

	/**
	 *
	 * @param boolean $loadFromDB determines how the initial values are acquired.
	 * If TRUE, the data will be forcefully loaded from the datastore, throwing
	 * an Exception if the data corresponding to this model have been removed.
	 * If FALSE, the data will be tentatively retrieved from the initial values
	 * stored in the Model, throw an Exception if these data
	 * have not been filled up (which depends on the method used to fill in
	 * the model's data). If NULL, initial values will be used if they exist,
	 * else it will be tried to load the model from the datastore, eventually
	 * throwing an Exception if no method works.
	 * @return Model
	 */
	private function doDoGetStoredCopy($loadFromDB = false) {
		if ($loadFromDB !== true && $this->internal->dbValues !== null) {
			return $this->table->createModel(
				$this->internal->dbValues, true, $this->context
			);
		} else if ($loadFromDB === false) {
			throw new IllegalStateException(
				get_class($this) . '::getStoredCopy(false) cannot be executed, '
				. 'the model\'s initial values have not been kept.'
			);
		} else {
			if (null === $m = $this->load($this->getPrimaryKeyValue(), $this->context)) {
				throw new IllegalStateException(
					get_class($this) . '::getStoredCopy(true) cannot be executed, '
					. 'the model\'s data have been removed from the database.'
				);
			} else {
				return $m;
			}
		}
	}

	protected function clearModified() {
		$this->internal->modified = false;
		$this->internal->colUpdated = null;
	}

	/**
	 * Get whether this Model has a primary key or not.
	 * @return Bool
	 */
	function hasPrimaryKey() {
		return $this->getTable()->hasPrimaryKey();
	}

	abstract function setPrimaryKeyValue($value);

	protected function setPrimaryKeyValueImpl($primaryKeyName, $value, $forceAcceptNull = false) {
		// $this->getLogger()->warn('Deprecated'); // why ???
		$this->setColumn($primaryKeyName, $value, $forceAcceptNull);
		// $this->setField($primaryKeyName, $value, $forceAcceptNull);
	}

	protected function setUndetermined($fieldName, $reason) {
		if (isset($this->undeterminedFields[$fieldName])) {
			$this->undeterminedFields[$fieldName][$reason] = true;
		} else {
			$this->undeterminedFields[$fieldName] = array(
				$reason => true
			);
		}
	}

	public function waitDetermination($fieldName, $callback) {
		if (is_array($fieldName)) {
			$wait = false;
			foreach ($fieldName as $field) {
				if ($this->isUndetermined($field)) {
					$wait = true;
					break;
				}
			}

			if ($wait) {
				$l = new ModelMultipleFieldDeterminationListener($fieldName, $callback);
				if ($this->determinationMultifieldListeners[$fieldName]) {
					$this->determinationMultifieldListeners[$fieldName][] = $l;
				} else {
					$this->determinationMultifieldListeners[$fieldName][] = array($l);
				}
			} else {
				$values = array();
				foreach ($fieldName as $field) {
					$values[$field] = $m->__get($field);
				}
				$callback($values);
			}

		} else {
			if ($this->isUndetermined($fieldName)) {
				if (isset($this->determinationListeners[$fieldName])) {
					$this->determinationListeners[$fieldName][] = $callback;
				} else {
					$this->determinationListeners[$fieldName] = array($callback);
				}
			} else {
				$callback($this->__get($fieldName));
			}
		}
	}

	protected function releaseUndeterminedIf($fieldName, $reason) {
		if (isset($this->undeterminedFields[$fieldName])) {
			$this->releaseUndetermined($fieldName, $reason);
		}
	}

	protected function releaseUndetermined($fieldName, $reason) {
		if (!isset($this->undeterminedFields[$fieldName])) {
			throw new IllegalArgumentException("Field $fieldName is not in an undetermined state");
		}
		unset($this->undeterminedFields[$fieldName][$reason]);

		if (count($this->undeterminedFields[$fieldName]) === 0) {
			unset($this->undeterminedFields[$fieldName]);

			if (isset($this->determinationListeners[$fieldName])) {
				$v = $this->__get($fieldName);
				foreach ($this->determinationListeners[$fieldName] as $l) {
					$l($v);
				}
				unset($this->determinationListeners[$fieldName]);
			}

			if ($this->determinationMultifieldListeners !== null) {
				foreach ($this->determinationMultifieldListeners as $i => $l) {
					$l instanceof ModelMultipleFieldDeterminationListener;
					if ($l->test($this)) {
						unset($this->determinationMultifieldListeners[$i]);
					}
				}
			}
		}
	}

	public function isUndetermined($fieldName) {
		return isset($this->undeterminedFields[$fieldName]);
	}

	public function getField($name) {
		if (isset($this->undeterminedFields[$name])) {
			throw new IllegalStateException(
				"The field $name is in an undetermined state"
			);
		}

		if (array_key_exists($name, $this->internal->fields)) {
			$v = $this->internal->fields[$name];
		} else if (
			$this->table->hasVirtual($name)
			|| $this->table->hasRelation($name)
		) {
			$m = 'get' . ucfirst($name);
			$v = $this->$m();
		}

		return $this->table->getField($name)->castValue($v);
	}

	/**
	 * @todo documentation out of date ($this->new has been deprecated in favor
	 * of $this->primaryKeyValue !== null)
	 *
	 * This method is for internal use by the Model class and its descendants
	 * only. Its use in the custom concrete implementation of a Model (ie. not
	 * in the Base class) is heavily discouraged. Instead, use the direct
	 * getter and setter method, or the publicly available setFields method,
	 * which checks both for field existence, and if they are primary keys or
	 * not.
	 *
	 * This method does <b>NOT</b> check for field existence.
	 *
	 * <b>Important</b>: this method must NOT be used to set the value of the
	 * primary field, or the save() method may fail (by attempting to create an
	 * already existing row, or the reverse).
	 *
	 * @param String $name
	 * @param mixed $value
	 * @return Model $this
	 */
	public function setField($name, $value, $forceAcceptNull = false) {

		if ($value === '') $value = null;

		if (isset($this->undeterminedFields[$name])) {
			throw new IllegalStateException(
				"The undetermination about the field $name must be released before it can be set"
			);
		}

		if (count($parts = preg_split('/->/', $name, 2)) == 2) {
			$this->setForeignModelValue($parts[0], $parts[1], $value, $forceAcceptNull);
		} else {
			if ($this->isForeignModel($name)) {
				$this->setForeignModel($name, $value, $forceAcceptNull);
			} else if (method_exists($this, $m = 'set' . Inflector::camelCase($name, true))) {
				$this->$m($value, $forceAcceptNull);
				// call_user_method($m, $this, $value, $forceAcceptNull);
			} else if ($this->getTable()->hasColumn($name)) {
				$this->setColumnNoLoadCheck($name, $value, $forceAcceptNull);
			} 

			// Let pass virtual fields... (they are loaded in certain cases and
			// may be returned to the server as is)
			else if ($this->getTable()->hasVirtual($name)) {
			} 

			else {
				Logger::get($this)->debug("'$name' is not a field from " . get_class($this));
//				throw new IllegalArgumentException("$name is not a field from " . get_class($this));
			}
		}

		return $this;
	}

	/**
	 * Internal method.
	 * @internal Callback for {@link setFieldFromModelPk}.
	 * @param <type> $fieldName
	 * @param Model $srcModel
	 */
	public function cbSetFieldFromModelPk_srcAfterSave($fieldName, Model $srcModel) {
		// Release undetermination on the field
		// Must be done before setField (cannot set when undetermined)
		$this->releaseUndetermined($fieldName, 'setFieldFromModelPk');
		$this->setField($fieldName, $srcModel->getPrimaryKeyValue());
	}

	/**
	 * Internal method.
	 * @internal Callback for {@link setFieldFromModelPk}.
	 * @param <type> $fieldName
	 * @param Model $srcModel
	 */
	public function cbSetFieldFromModelPk_thisBeforeSave(Model $srcModel) {
		if ($srcModel->isNew()) {
			// 04/12/11 08:13
			// Save the referred model before saving this model (instead of crashing)
			$srcModel->save(true);
//			dumpl(array(
//				'this' => $this
//				,'srcModel' => $srcModel
//			));
//			throw new ModelSaveException(get_class($srcModel) . ' needs to be saved before');
		}
	}

	/**
	 * Set the specified field of this Model to the value of the given $model
	 * primary key's value. If the given Model is new, then it will be waited
	 * until the source model is saved to get its primary key and set the value.
	 * In this case, if a tentative to save this model before the source model
	 * itself has been saved, then an exception will be thrown. Moreover, if the
	 * value of the field specified by $fieldName is read before its value could
	 * have been set (that is, before the source model has been saved if it was
	 * new), a ModelSaveException will also be raised.
	 * @param string $fieldName
	 * @param Model $srcModel
	 * @throws ModelSaveException if the source model is new and this model is
	 * tried to be saved before the source model is saved ; or if the value of
	 * the target field is tried to be read before the source model has been
	 * saved.
	 */
	public function setFieldFromModelPk($fieldName, Model $srcModel) {
		if ($srcModel === null) {
			throw new IllegalArgumentException('$model cannot be null');
		}
		if ($srcModel->isNew()) {
			$this->setUndetermined($fieldName, 'setFieldFromModelPk');
			$srcModel->onOnce(self::EVT_AFTER_SAVE_BASE,
				array($this, 'cbSetFieldFromModelPk_srcAfterSave'),
				array($fieldName, $srcModel)
			);
			$this->onOnce(self::EVT_BEFORE_SAVE_BASE,
				array($this, 'cbSetFieldFromModelPk_thisBeforeSave'),
				array($srcModel)
			);
		} else {
			$this->setField($fieldName, $srcModel->getPrimaryKeyValue());
		}
	}

	public function setColumn($name, $value, $forceAcceptNull = false) {

		if (isset($this->undeterminedFields[$name])) {
			throw new IllegalStateException(
				"The undetermination about the field $name must be released before it can be set"
			);
		}

		return $this->setColumnNoLoadCheck($name, $value, $forceAcceptNull);
	}

	/**
	 * Set the value of one of this reccord's field. This method is equivalent
	 * to the {@link setField()} method, except that it does not check if the
	 * reccord's data need to be loaded. It is use for a better performance of
	 * the batch setting functions ({@link setFields()} and {@link setAllFields()}).
	 * @param String $name
	 * @param mixed $value
	 * @return Model
	 */
	private function setColumnNoLoadCheck($name, $value, $forceAcceptNull = false,
			$testChanged = null) {

		if ($testChanged !== null) {
			throw new DeprecatedException('$testChanged parameter has been deprecated');
		}

		$table = $this->getTable();
		if ($table->hasColumn($name)) {

			$col = $table->getColumn($name);
			$v = $col->convertValueToSQL($value);

			// 2012-11-20 moved here (see bellow)
			$previous = isset($this->internal->fields[$name]) ? $this->internal->fields[$name] : null;
			$v = $this->applyFieldValue($name, $v);
			$this->internal->fields[$name] = $v;

			if ($v === null && !$forceAcceptNull && !$col->isNullable() && (!$col->isPrimary())) {
				throw new IllegalArgumentException($this->getModelName() . '.' . $name . ' cannot be null');
			}

			// 11/12/11 23:04 changed:
			// if ($this->internal->fields[$name] != $v || !$testChanged) { 
			// 02/11/12 12:24 changed
 			// if ($this->internal->fields[$name] !== $v || !$testChanged) {
			if (!$this->dbImage || $v !== $previous) {
				// 2012-11-20 moved before the if
				// $this->internal->fields[$name] = $this->applyFieldValue($name, $v);
				$this->internal->colUpdated[$name] = true;
				$this->internal->modified = true;
				return true;
			} else {
				return false;
			}
		}
	}

	protected function isForeignModel($name) {
		return $this->getTable()->hasRelation($name);
	}

	protected function setForeignModel($name, $value, $forceAcceptNull = false) {
		$this->getRelation($name)->set($value, $forceAcceptNull);
	}

	protected function setForeignModelValue($name, $field, $value, $forceAcceptNull = false) {
		$this->getRelation($name)->setField($field, $value, $forceAcceptNull);
	}

	/**
	 * @param $name
	 * @param array $overrideContext
	 * @return Model|ModelSet
	 */
	protected function getForeignModel($name, array $overrideContext = null) {
		return $this->getRelation($name)->get($overrideContext);
	}

	/**
	 * Set multiple fields value. Setter keys that do not match any field in the
	 * model will be silently ignored.
	 * @param array $setters
	 */
	public function setFields(array $setters, $forceAcceptNull = false) {
		foreach ($setters as $k => $v) {
			// setField will test for the field existence
			$this->setField($k, $v, $forceAcceptNull);
		}
	}

// 02/11/12 12:23 Deprecated
//	/**
//	 * Set multiple columns value
//	 * @param array $setters
//	 */
//	public function setColumns(array $setters, $forceAcceptNull = false, $testChanged = true) {
//
////REMLOAD		if ($this->internal->needsLoading) $this->doLoad();
//
////		$col = $this->getTable()->getColumn('conjoint__contacts_id');
////		echo($col->convertValueToSQL($setters['conjoint__contacts_id']) === null);die;
//
//		foreach ($setters as $k => $v) {
//			$this->setColumnNoLoadCheck($k, $v, $forceAcceptNull, $testChanged);
////			if (!$this->setColumnNoLoadCheck($k, $v)) {
////				Logger::getLogger('Model')->warn('Setting inexistant key in model: {}[{}]',
////						$this->getModelName(), $k);
////			}
//		}
//	}

	/**
	 * Convert the given value for the specified field using a custom algorithm. The default
	 * implementation looks for a method named `'apply' . ucfirst($fieldName)` and use it if
	 * it is present, otherwise it returns the value unmodified (pass through).
	 *
	 * @param string $fieldName
	 * @param mixed $value
	 * @return mixed
	 */
	protected function applyFieldValue($fieldName, $value) {
		$method = 'apply' . ucfirst($fieldName);
		if (method_exists($this, $method)) {
			return $this->$method($value);
		} else {
			return $value;
		}
	}

	protected function setAllFieldsFromDatabase(array $setters) {
		$this->internal->dbValues = array();
		foreach ($this->internal->fields as $field => $v) {
			if (!array_key_exists($field, $setters)) {
				throw new IllegalArgumentException('Missing field in ' . $this->getModelName() . ': ' . $field);
			}
			$this->internal->fields[$field] = $this->applyFieldValue($field, $setters[$field]);
			$this->internal->dbValues[$field] = $setters[$field];
		}
		// Load virtual fields
		// nota: that requires the given $setters to have been loaded by the
		// table's createLoadQuery method
		foreach ($this->table->getVirtualNames() as $virtual) {
			if (!array_key_exists($virtual, $setters)) {
				Logger::getLogger($this)->warn('Model "{}" not synchronized: '
						. 'missing virtual field `{}` in database result', get_class($this), $virtual);
			} else {
				$this->internal->dbValues[$field] = 
				$this->internal->fields[$virtual] = $setters[$virtual];
			}
		}
		$this->dbImage = true;
	}

	/**
	 * Set all this Model's fields value. This method will throw an
	 * IllegalArgumentException if some of the fields of the Model are missing
	 * from the supplied array, or if a given value is identified as forbidden
	 * for the matching column (eg. as time of writting, null value for
	 * not-nullable column will trigger this error).
	 * @param array $setters
	 * @return Model
	 * @throws IllegalArgumentException if some of the fields of the Model are missing
	 * from the supplied array
	 */
	public function setAllFields(array $setters) {

//REMLOAD		if ($this->internal->needsLoading) $this->doLoad();

//		if (is_array($setters)) {
			foreach ($this->internal->fields as $field => $v) {
				if (!array_key_exists($field, $setters)) {
					throw new IllegalArgumentException('Missing field in ' . $this->getModelName() . ': ' . $field);
				}
				$this->setColumnNoLoadCheck($field, $setters[$field], false);
			}
//		} else if ($setters instanceof ArrayAccess) {
//			foreach (array_keys($this->internal->fields) as $field) {
//				if (!isset($field, $setters)) {
//					throw new IllegalArgumentException('Missing field in ' . $this->getModelName() . ': ' . $field);
//				}
//				$this->setFieldOrPrimaryKey($field, $setters[$field]);
//			}
//		} else {
//			throw new IllegalArgumentException('$setters must be either an array or an ArrayAccess object');
//		}

//		return $this;
	}

	public function __toString() {
		try {
			$fields = $this->getFields();
			$s = $this->getModelName() . '{ ';
			$comma = '';
			foreach ($fields as $k => $v) {
				$s .= "$comma'$k' => " . Debug::valueToReadable($v);
				$comma = ', ';
			}
			$s .= ' }';
			return $s;
		} catch (Exception $ex) {
			Logger::get($this)->error('__toString Exception: ' . $ex);
		}
		return '';
	}

	protected function getRelations() {
		$r = array();
		foreach ($this->getTable()->getRelationsInfo() as $relInfo) {
			$r[$relInfo->name] = $this->getRelation($relInfo->name);
		}
		return $r;
	}

	/**
	 * Get the relation with the specified $name, creating it if it has not
	 * already been instanciated.
	 * @param String $name
	 * @return ModelRelation
	 */
	final public function getRelation($name) {
		// Instanciate
		if (!isset($this->internal->relations[$name])) {
//			require_once PHP_PATH . '_/ModelRelation.class.php';
			$this->internal->relations[$name] = $this->internal->relations[$name] = $this->table
					->getRelationInfo($name)
					->createRelation($this);
		}
		// Return
		return $this->internal->relations[$name];
	}

	/**
	 * Get the specified relation if it has been modified (ie. set) in the
	 * current Model.
	 * @param string $name
	 * @return ModelRelation
	 * @throws IllegalArgumentException if the Model doesn't have a relation
	 * named $name {@internal (if a relation with the given name has been
	 * instanciated in the Model, it will be returned and no Exception will
	 * be thrown, even if the Model's ModelTable doesn't declare the said
	 * relation)}}.
	 */
	public function getRelationIf($name) {
		if (isset($this->internal->relations[$name])) {
			return $this->internal->relations[$name];
		} else if($this->table->hasRelation($name)) {
			return null;
		} else {
			throw new IllegalArgumentException(
				get_class($this) . " has no relation '$name'"
			);
		}
	}

	/**
	 * Will delete the link with the given relation, if it exists. This change
	 * will <b>NOT</b> be committed to the database (ie. the currently reccorded
	 * relation will be kept).
	 * @param string|ModelRelation $relation
	 */
	public function unlinkRelation($relation) {
		if ($relation instanceof ModelRelation) $relation = $relation->name;
		unset($this->internal->relations[$relation]);
	}

	public function unlinkRelationByName($name) {
		unset($this->internal->relations[$name]);
	}

	/**
	 * Will delete the links with all relations. This change will <b>NOT</b> be
	 * committed to the database (ie. the currently reccorded relations will be
	 * kept).
	 */
	public function unlinkRelations() {
		$this->internal->relations = array();
	}

	/**
	 *
	 * @return ModelInternal
	 */
	public function getInternal() {
		return $this->internal;
	}
}

class ModelInternal {

	/** @var Model */
	public $model;

	public $fields;
	public $colUpdated = null;
	public $dbValues = null;

	public $relations = array();

	public $modified = false;

	public function __construct(&$model) {
		$this->model = $model;
	}

	public function setRelation(ModelRelation $relation) {

		$name = $relation->name;

		if (!$this->model->getTable()->hasRelation($name)) {
			throw new IllegalArgumentException("'$name' is not a relation of '" . get_class($this->model) . "'");
		}

//		if ($this->relations[$name] !== null) {
		if (isset($this->relations[$name])) {
			throw new IllegalStateException();
		}

		$this->relations[$name] = $relation;
	}

}

class ModelSaveException extends SystemException {

}

/**
 * This exception is thrown when a model's field which is in an undetermined
 * state is tried to be written or read.
 * 
 * Undetermined state means that an event is being waited for, in order to set
 * the field's value. Until that happens, the field cannot be read, since its
 * value is not yet known; and it cannot be written, because when the event
 * happens, it will not be possible to know which value should be used, 
 * between the newly set one and the event's one.
 * 
 * If you encounter this exception in your code, you should change your design
 * so that you can be sure that the setField method (or any method depending on
 * it) is called before or after the undetermination is resolved.
 * 
 * Methods that creates undetermination are mainly the ones that must wait for
 * another model to be saved in order to read value(s) from it (for example:
 * {@link Model::setFieldFromModelPk}.
 */
class ModelUndeterminedFieldException extends SystemException {

}

class ModelMultipleFieldDeterminationListener {

	public $fields;
	public $callback;

	function __construct($fields, $callback) {
		$this->fields = $fields;
		$this->callback = $callback;
	}

	public function test(Model $m) {
		foreach ($this->fields as $field) {
			if ($m->isUndetermined($field)) return false;
		}

		// done
		$values = array();
		foreach ($this->field as $field) {
			$values[$field] = $m->__get($field);
		}
		$fn = $this->callback;
		$fn($values);

		return true;
	}

}
